using System.Text;
using StockConsole.Model;

namespace StockConsole.Services;

/// <summary>
/// This Code was generated by Claude.ai
/// </summary>
public class ChartService : IChartService
{
    private const int ChartHeight = 15;
    private const char UpBodyChar = '█';    // Full block for up days
    private const char DownBodyChar = '░';  // Light shade for down days - better distinction
    private const char WickChar = '│';      // Box drawings light vertical
    private const char AxisChar = '│';
    private const char HorizontalLineChar = '─';
    
    public string RenderCandlestickChart(List<DailyPriceData> timeSeries)
    {
        var sb = new StringBuilder();
        
        decimal minPrice = timeSeries.Min(d => d.Low);
        decimal maxPrice = timeSeries.Max(d => d.High);
        decimal priceRange = maxPrice - minPrice;
        
        decimal padding = priceRange * 0.1m;
        minPrice -= padding;
        maxPrice += padding;
        priceRange = maxPrice - minPrice;
        
        if (priceRange == 0)
            priceRange = 1;
        
        sb.AppendLine($"Candlestick Chart (Last {timeSeries.Count} days)");
        sb.AppendLine(new string('-', timeSeries.Count * 2 + 15));
        
        sb.AppendLine($"{maxPrice:F2} {AxisChar}");
        
        DrawCandles(timeSeries, maxPrice, priceRange, sb);
        
        // Add bottom price scale
        sb.Append($"{minPrice:F2} {AxisChar}");
        sb.AppendLine(new string(HorizontalLineChar, timeSeries.Count * 2));
        
        // Add day markers at bottom with better spacing
        sb.Append("       ");
        for (int i = 0; i < timeSeries.Count; i++)
        {
            if (i < 9)
                sb.Append($"{i+1} ");
            else
                sb.Append($"{i+1}");
            
            if (i < timeSeries.Count - 1 && i >= 9)
                sb.Append(" ");
        }
        
        // Add legend
        sb.AppendLine();
        sb.AppendLine();
        sb.AppendLine($"Legend: {UpBodyChar} Up day   {DownBodyChar} Down day   {WickChar} Price range/wick");
        
        return sb.ToString();
    }

    private static void DrawCandles(List<DailyPriceData> timeSeries, decimal maxPrice, decimal priceRange, StringBuilder sb)
    {
        for (int row = 0; row < ChartHeight; row++)
        {
            // Calculate the price level for this row
            decimal rowPrice = maxPrice - (row * priceRange / ChartHeight);
            
            // Start with price label and axis
            sb.Append($"{rowPrice:F2} {AxisChar}");
            
            // Draw candles in each column
            for (int i = 0; i < timeSeries.Count; i++)
            {
                var data = timeSeries[i];
                var isUpDay = data.Close >= data.Open;
                
                // Calculate normalized positions (0 to ChartHeight-1)
                int highPos = NormalizePrice(data.High, maxPrice, priceRange);
                int lowPos = NormalizePrice(data.Low, maxPrice, priceRange);
                int openPos = NormalizePrice(data.Open, maxPrice, priceRange);
                int closePos = NormalizePrice(data.Close, maxPrice, priceRange);
                
                // Current row position (0 at top, ChartHeight-1 at bottom)
                int currentPos = row;
                
                // Determine what to draw at this position
                var charToDraw = CharToDraw(currentPos, highPos, lowPos, openPos, closePos, isUpDay);

                // Add a space after each character to improve spacing in terminals
                sb.Append(charToDraw + " ");
            }
            
            sb.AppendLine();
        }
    }

    private static char CharToDraw(int currentPos, int highPos, int lowPos, int openPos, int closePos, bool isUpDay)
    {
        char charToDraw = ' ';

        if (currentPos >= highPos && currentPos <= lowPos)
        {
            if (currentPos >= Math.Min(openPos, closePos) && currentPos <= Math.Max(openPos, closePos))
            {
                charToDraw = isUpDay ? UpBodyChar : DownBodyChar;
            }
            else
            {
                charToDraw = WickChar;
            }
        }

        return charToDraw;
    }

    private static int NormalizePrice(decimal price, decimal maxPrice, decimal priceRange)
    {
        return (int)Math.Round((maxPrice - price) / priceRange * ChartHeight);
    }
}