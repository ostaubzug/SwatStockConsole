name: C4 Documentation Generator with DeepSeek

on:
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  generate-c4-docs:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for proper analysis

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Setup GraphViz (for PlantUML)
        run: sudo apt-get update && sudo apt-get install -y graphviz

      - name: Install AsciiDoctor and PlantUML dependencies
        run: |
          sudo apt-get install -y ruby
          sudo gem install asciidoctor
          sudo gem install asciidoctor-diagram
          mkdir -p .asciidoctor/diagram
          wget https://github.com/plantuml/plantuml/releases/download/v1.2023.10/plantuml-1.2023.10.jar -O .asciidoctor/diagram/plantuml.jar

      - name: Install code-context-llm
        run: npm install -g code-context-llm

      - name: Generate code context for LLM
        run: |
          npx code-context-llm --project-path . --output-file temp_project_structure.md --skip-dirs dist,build --skip-files .env 
          echo "Code context generated"

      - name: Create temp directory for processing files
        run: mkdir -p temp_processing

      - name: Convert Markdown to JSON for DeepSeek API
        run: |
          cat > temp_processing/markdown-to-json.js <<'EOF'
          const fs = require('fs');

          try {
            // Read the Markdown file generated by code-context-llm
            const markdownContent = fs.readFileSync('temp_project_structure.md', 'utf8');

            // Create a simple structure to represent code context
            const codeContext = {
              projectName: "SwatStockConsole",
              files: [],
              description: "A console application for retrieving and displaying stock data"
            };

            // Parse the Markdown to extract file information
            const lines = markdownContent.split('\n');
            let currentFile = null;
            let collectingCode = false;

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];

              // Detect file sections
              if (line.includes('.cs (') && line.trim().endsWith('bytes)')) {
                // Extract filename from line like "    - DailyPriceData.cs (215 bytes)"
                const match = line.match(/\s*-\s*([\w\/\.]+\.cs)\s*\((\d+) bytes\)/);
                if (match) {
                  const [_, fileName, size] = match;
                  currentFile = {
                    path: fileName,
                    size: parseInt(size),
                    content: "",
                    previewFound: false
                  };
                  codeContext.files.push(currentFile);
                }
              }

              // Look for content preview
              if (currentFile && line.trim() === "Content preview:") {
                collectingCode = true;
                currentFile.previewFound = true;
                i++; // Skip the "```" line
                continue;
              }

              // Collect code content from preview section
              if (collectingCode && currentFile && currentFile.previewFound) {
                if (line === "```") {
                  collectingCode = false;
                } else {
                  currentFile.content += line + "\n";
                }
              }
            }

            // Write converted data to JSON file
            fs.writeFileSync('temp_processing/code-context.json', JSON.stringify(codeContext, null, 2));
            console.log("Successfully converted Markdown to JSON");

          } catch (error) {
            console.error("Error processing Markdown file:", error);
            process.exit(1);
          }
          EOF

          # Run the conversion script
          node temp_processing/markdown-to-json.js

      - name: Create C4 diagrams directory
        run: mkdir -p docs/c4/diagrams

      - name: Generate and execute C4 models script
        env:
          DEEPSEEK_API_KEY: ${{ secrets.DEEPSEEK_API_KEY }}
        run: |
          cat > temp_processing/generate-c4-diagrams.js <<'EOF'
          const fs = require('fs');
          const path = require('path');
          const https = require('https');
          
          // Read the code context
          const codeContext = JSON.parse(fs.readFileSync('temp_processing/code-context.json', 'utf8'));
          
          // Function to call DeepSeek API
          async function callDeepSeekAPI(prompt, outputFile, diagramType) {
            return new Promise((resolve, reject) => {
              const apiKey = process.env.DEEPSEEK_API_KEY;
          
              if (!apiKey) {
                reject(new Error('DEEPSEEK_API_KEY is not set'));
                return;
              }
          
              console.log(`Calling DeepSeek API for ${diagramType} diagram...`);
          
              const data = JSON.stringify({
                model: "deepseek-reasoner",
                messages: [
                  {
                    role: "system", 
                    content: "You are an expert software architect who specializes in creating C4 model diagrams using PlantUML syntax. Always use the official C4-PlantUML macros (Component(), Interface(), Rel(), Container_Boundary(), etc.) instead of custom PlantUML syntax. Pay special attention to proper C4-PlantUML syntax for interfaces and relationships. Be extremely careful to generate valid PlantUML code that will render correctly."
                  },
                  { role: "user", content: prompt }
                ],
                temperature: 0.1,
                max_tokens: 4096
              });
          
              const options = {
                hostname: 'api.deepseek.com',
                path: '/chat/completions',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${apiKey}`,
                  'Content-Length': data.length
                }
              };
          
              console.log(`API request prepared for ${diagramType} diagram`);
          
              const req = https.request(options, (res) => {
                let responseData = '';
          
                console.log(`API status code: ${res.statusCode}`);
          
                res.on('data', (chunk) => {
                  responseData += chunk;
                });
          
                res.on('end', () => {
                  try {
                    console.log(`Received response for ${diagramType} diagram`);
                    const parsedResponse = JSON.parse(responseData);
                    if (parsedResponse.error) {
                      console.error(`API error: ${JSON.stringify(parsedResponse.error)}`);
                      reject(new Error(`API error: ${parsedResponse.error.message}`));
                      return;
                    }
          
                    const plantUmlContent = extractPlantUMLFromResponse(parsedResponse.choices[0].message.content);
          
                    // Save the PlantUML content to the specified file
                    fs.writeFileSync(outputFile, plantUmlContent);
                    console.log(`Generated ${diagramType} diagram: ${outputFile}`);
          
                    resolve(plantUmlContent);
                  } catch (error) {
                    console.error(`Failed to parse API response: ${error.message}`);
                    console.error(`Response: ${responseData.substring(0, 200)}...`);
                    reject(new Error(`Failed to parse API response: ${error.message}`));
                  }
                });
              });
          
              req.on('error', (error) => {
                console.error(`API request failed: ${error.message}`);
                reject(new Error(`API request failed: ${error.message}`));
              });
          
              req.write(data);
              req.end();
              console.log(`API request sent for ${diagramType} diagram`);
            });
          }
          
          // Function to extract PlantUML code from the response
          function extractPlantUMLFromResponse(response) {
            console.log("Extracting PlantUML from response...");
            // Look for PlantUML code between @startuml and @enduml tags
            const match = response.match(/@startuml[\s\S]*?@enduml/);
            if (match) {
              console.log("Found @startuml/@enduml tags");
              return match[0];
            }
          
            // If no explicit tags, look for PlantUML-like content
            const lines = response.split('\n');
            let inCodeBlock = false;
            let plantUmlContent = [];
            let foundPlantUml = false;
          
            for (const line of lines) {
              if (line.trim().startsWith('```plantuml') || line.trim().startsWith('```puml')) {
                inCodeBlock = true;
                foundPlantUml = true;
                plantUmlContent.push('@startuml');
                continue;
              }
          
              if (inCodeBlock && line.trim() === '```') {
                inCodeBlock = false;
                plantUmlContent.push('@enduml');
                continue;
              }
          
              if (inCodeBlock) {
                plantUmlContent.push(line);
              }
            }
          
            if (foundPlantUml) {
              console.log("Found ```plantuml code block");
              return plantUmlContent.join('\n');
            }
          
            // If still no PlantUML content found, wrap the entire response
            console.log("No PlantUML markers found, using response as raw content");
            return `@startuml\n${response}\n@enduml`;
          }
          
          // Generate context prompt from code context
          function generateContextPrompt(diagramType) {
            let prompt = `Based on the following code context, generate a C4 ${diagramType} diagram using PlantUML syntax.\n\n`;
            prompt += `Code context:\n${JSON.stringify(codeContext, null, 2)}\n\n`;
          
            switch (diagramType) {
              case 'Context':
                prompt += "Create a System Context diagram showing the SwatStockConsole application, its users, and external dependencies like the Alpha Vantage API. Focus on high-level relationships between systems.";
                break;
              case 'Container':
                prompt += "Create a Container diagram showing the main components within the SwatStockConsole application. Include the API service, chart service, models, utilities, and console application containers and how they interact.";
                break;
              
              case 'Component':
                prompt += "Create a Component diagram detailing the internal components of the SwatStockConsole application, showing interfaces, implementations, and their relationships.\n\n";
                prompt += "IMPORTANT: Follow these strict guidelines for C4 Component diagrams:\n";
                prompt += "1. Always use the official C4-PlantUML macros instead of custom PlantUML syntax:\n";
                prompt += "   - Use Component() for components\n";
                prompt += "   - Use Interface() for interfaces\n";
                prompt += "   - Use Rel(), Rel_D(), Rel_U(), Rel_L(), Rel_R() for relationships\n";
                prompt += "   - Use Container_Boundary() for boundaries\n\n";
                prompt += "2. Structure your PlantUML as follows:\n";
                prompt += "```\n";
                prompt += "@startuml\n";
                prompt += "!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml\n\n";
                prompt += "Container_Boundary(container, \"Container Name\") {\n";
                prompt += "    Component(comp1, \"Component 1\", \"Technology\", \"Description\")\n";
                prompt += "    Component(comp2, \"Component 2\", \"Technology\", \"Description\")\n";
                prompt += "    Interface(interface1, \"Interface Name\")\n";
                prompt += "    \n";
                prompt += "    Rel(comp1, interface1, \"Uses\")\n";
                prompt += "    Rel(comp2, interface1, \"Implements\")\n";
                prompt += "}\n";
                prompt += "@enduml\n";
                prompt += "```\n\n";
                prompt += "DO NOT use rectangle elements or custom stereotypes. ONLY use the official C4-PlantUML macros.";
                break;    
              
              case 'Code':
                prompt += "Create a detailed Code diagram showing key classes, interfaces, and their relationships within the SwatStockConsole application.";
                break;
            }
          
            prompt += "\n\nUse the C4-PlantUML syntax and ensure your diagram follows C4 model best practices. Return only the PlantUML code without explanations.";
          
            return prompt;
          }
          
          // Main execution
          async function generateAllDiagrams() {
            try {
              // Define the diagrams to generate
              const diagrams = [
                { type: 'Context', file: 'docs/c4/diagrams/c4_context.puml' },
                { type: 'Container', file: 'docs/c4/diagrams/c4_container.puml' },
                { type: 'Component', file: 'docs/c4/diagrams/c4_component.puml' }
              ];
          
              for (const diagram of diagrams) {
                console.log(`Starting generation of ${diagram.type} diagram`);
                const prompt = generateContextPrompt(diagram.type);
                await callDeepSeekAPI(prompt, diagram.file, diagram.type);
              }
          
              // Generate the AsciiDoc file
              generateAsciiDoc();
          
              console.log('All diagrams generated successfully');
            } catch (error) {
              console.error('Error generating diagrams:', error);
              process.exit(1);
            }
          }
          
          function generateAsciiDoc() {
            // Build AsciiDoc content using string concatenation to avoid YAML parsing issues
            let asciidocContent = "";
            asciidocContent += "= SwatStockConsole C4 Architecture Documentation\n\n";
            asciidocContent += ":toc: left\n";
            asciidocContent += ":toclevels: 3\n";
            asciidocContent += ":sectnums:\n";
            asciidocContent += ":plantuml-format: svg\n\n";
          
            asciidocContent += "== Introduction\n\n";
            asciidocContent += "This document provides the C4 model architecture documentation for the SwatStockConsole application.\n";
            asciidocContent += "The diagrams are automatically generated based on code analysis using DeepSeek AI.\n\n";
          
            asciidocContent += "== C4 Model\n\n";
            asciidocContent += "The C4 model is a simple way to document software architecture using four levels:\n\n";
            asciidocContent += "1. System Context: People and software systems\n";
            asciidocContent += "2. Containers: Applications and data stores\n";
            asciidocContent += "3. Components: Groups of related functionality\n";
            asciidocContent += "4. Code: Classes, interfaces, etc.\n\n";
          
            asciidocContent += "=== System Context Diagram\n\n";
            asciidocContent += "The System Context diagram shows the SwatStockConsole system in context with its users and external dependencies.\n\n";
            asciidocContent += "[plantuml, \"c4-context-diagram\", svg]\n";
            asciidocContent += "....\n";
            asciidocContent += "include::diagrams/c4_context.puml[]\n";
            asciidocContent += "....\n\n";
          
            asciidocContent += "=== Container Diagram\n\n";
            asciidocContent += "The Container diagram shows the major components within the SwatStockConsole system.\n\n";
            asciidocContent += "[plantuml, \"c4-container-diagram\", svg]\n";
            asciidocContent += "....\n";
            asciidocContent += "include::diagrams/c4_container.puml[]\n";
            asciidocContent += "....\n\n";
          
            asciidocContent += "=== Component Diagram\n\n";
            asciidocContent += "The Component diagram shows the internal components of the SwatStockConsole application.\n\n";
            asciidocContent += "[plantuml, \"c4-component-diagram\", svg]\n";
            asciidocContent += "....\n";
            asciidocContent += "include::diagrams/c4_component.puml[]\n";
            asciidocContent += "....\n\n";
          
            asciidocContent += "== Implementation Details\n\n";
            asciidocContent += "The SwatStockConsole application is a .NET console application that retrieves stock data from Alpha Vantage API\n";
            asciidocContent += "and displays it as candlestick charts in the console.\n\n";
          
            asciidocContent += "=== Key Components\n\n";
            asciidocContent += "- AlphaVantageApiService: Handles communication with the Alpha Vantage API\n";
            asciidocContent += "- ChartService: Renders ASCII-based candlestick charts\n";
            asciidocContent += "- JsonUtility: Parses JSON responses from the API\n";
            asciidocContent += "- Client: Orchestrates the application flow\n";
            asciidocContent += "- DailyPriceData: Data model for daily stock price information\n\n";
          
            asciidocContent += "== Maintenance\n\n";
            asciidocContent += "This documentation is automatically generated from the codebase.\n";
            asciidocContent += "The diagrams are created using DeepSeek AI to analyze the code structure.\n\n";
          
            asciidocContent += "Last generated: " + new Date().toISOString();
          
            fs.writeFileSync('docs/c4/c4_documentation.adoc', asciidocContent);
            console.log('AsciiDoc file generated: docs/c4/c4_documentation.adoc');
          }
          
          // Start generation
          generateAllDiagrams();
          EOF

          # Execute the script
          node temp_processing/generate-c4-diagrams.js
          
          # Verify that the files were created
          ls -la docs/c4/diagrams/
          cat docs/c4/c4_documentation.adoc

      - name: Add C4 PlantUML includes to diagram files
        run: |
          for file in docs/c4/diagrams/*.puml; do
            # Add includes at the beginning of the file after @startuml
            sed -i '/@startuml/a !include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml\n!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml' "$file"
          done

      - name: Generate HTML documentation
        run: |
          asciidoctor -r asciidoctor-diagram -a diagram-cachedir=.asciidoctor/diagram/cache -a plantuml-timeout=30 -D docs/c4/html docs/c4/c4_documentation.adoc
          echo "HTML documentation generated"

      - name: Verify documentation files
        run: |
          echo "Checking for documentation files..."
          ls -la docs/c4/diagrams/
          ls -la docs/c4/
          ls -la docs/c4/html/

      - name: Cleanup temporary files
        run: |
          rm -rf temp_processing
          rm -f temp_project_structure.md
          rm -rf .asciidoctor
    
      - name: Create branch for documentation update
        id: create-branch
        run: |
          BRANCH_NAME="docs/c4-update-$(date +%Y%m%d%H%M%S)"
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'
          git checkout -b $BRANCH_NAME
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
    
      - name: Commit documentation changes
        id: commit
        run: |
          git add docs/c4/
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            git commit -m "Update C4 documentation [skip ci]"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi
    
      - name: Push changes and create PR
        if: steps.commit.outputs.has_changes == 'true'
        run: |
          git push origin ${{ steps.create-branch.outputs.branch_name }}
          gh pr create --title "Update C4 documentation" \
            --body "This PR updates the C4 architecture documentation based on recent code changes." \
            --base main \
            --head ${{ steps.create-branch.outputs.branch_name }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs/c4/html
 